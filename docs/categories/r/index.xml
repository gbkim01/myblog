<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R | 日常茶飯事</title>
    <link>/categories/r/</link>
      <atom:link href="/categories/r/index.xml" rel="self" type="application/rss+xml" />
    <description>R</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2019</copyright><lastBuildDate>Sat, 12 Oct 2019 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>R</title>
      <link>/categories/r/</link>
    </image>
    
    <item>
      <title>WSl을 이용해 R 사용하기</title>
      <link>/post/wsl%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%B4-r-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Sat, 12 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/post/wsl%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%B4-r-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
      <description>

&lt;h2 id=&#34;using-r-on-wsl-windows-subsystem-for-linux&#34;&gt;&lt;strong&gt;Using R on WSL(Windows Subsystem for Linux)&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;WSL에 &lt;strong&gt;Rstudio-server&lt;/strong&gt;를 설치하면 윈도우 브라우저를 통해 리눅스 버전의 R을 사용할 수 있는데, 이를 위한 기본적인 설정 방법과 의존성 문제 해결방법 등을 정리해서 올린다. WSL은 우분투 18.04 LTS 버전을 기준으로 한다.&lt;/p&gt;

&lt;h3 id=&#34;1-microsoft-r-open-설치&#34;&gt;1. Microsoft R Open 설치&lt;/h3&gt;

&lt;p&gt;우분투는 기본저장소를 통해 R 패키지를 제공하고 있다. 사용자는 우분투 터미널 창에 &lt;code&gt;sudo apt install r-base r-base-core&lt;/code&gt; 명령문을 실행시켜 간단하게 R을 설치할 수 있다. 그러나 이번에는 기본 R이 아닌 MS사가 제공하는 &lt;strong&gt;MRO(Microsoft R Open)&lt;/strong&gt; 버전의 R을 설치하는 것을 택했다. 기본 R이 최신버전인 R_3.6이 아니라 R_3.4 이기도 하고, 들리는 말로는 MRO가 멀티 쓰레드 연산에 이점이 있다고 하니 기왕이면 MRO를 설치하자.&lt;/p&gt;

&lt;p&gt;먼저 &lt;a href=&#34;https://mran.microsoft.com/download&#34; target=&#34;_blank&#34;&gt;MRO링크&lt;/a&gt;를 방문하여 우분투용 설치파일을 윈도우 다운로드 폴더에 다운받는다. 현재 MRO 최신버전은 3.5.3이다. 그리고 우분투 bash terminal에 다음의 코드를 실행시킨다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /mnt/c/Users/사용자명/Downloads
$ tar -xf microsoft-r-open-3.5.3.tar.gz
$ cd microsoft-r-open
$ sudo ./install.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WSL에서는 윈도우10 폴더가 마치 외장하드인 마냥 접근할 수 있다. &lt;code&gt;cd /mnt/c/Users/사용자명/Downloads&lt;/code&gt;를 통해 윈도우의 다운로드 폴더에 접근한 후, 다운받은 파일인 &lt;strong&gt;microsoft-r-open-3.5.3.tar.gz&lt;/strong&gt;을 압축해제하여 설치 스크립트 &lt;code&gt;sudo ./install.sh&lt;/code&gt;를 실행한다.&lt;/p&gt;

&lt;p&gt;설치과정을 완료하고 다시 우분투 터미널에 &lt;code&gt;R&lt;/code&gt;을 치면 터미널 상에 다음과 같은 화면이 나온다. MRO 설치가 완료되었다.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src = &#34;https://user-images.githubusercontent.com/30010992/66693086-0b6c7f00-ece0-11e9-88c4-83ac57ba4444.PNG&#34; width=80%&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-rstudio-server-설치&#34;&gt;2. Rstudio-Server 설치&lt;/h3&gt;

&lt;p&gt;이제 윈도우의 웹브라우저를 통해 WSL의 R에 접속하여 사용할 수 있도록 Rstudio-server를 설치해야 한다. 방법은 매우 간단하다. &lt;a href=&#34;https://rstudio.com/products/rstudio/download-server/debian-ubuntu/&#34; target=&#34;_blank&#34;&gt;링크&lt;/a&gt;에 나온 설명을 따라 그대로 우분투 터미널에 다음의 코드를 입력하면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install gdebi-core
$ wget https://download2.rstudio.org/server/trusty/amd64/rstudio-server-1.2.5001-amd64.deb
$ sudo gdebi rstudio-server-1.2.5001-amd64.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;버전이 업데이트 되면 위의 코드가 조금씩 변경될 수 있으니 반드시 &lt;a href=&#34;https://rstudio.com/products/rstudio/download-server/debian-ubuntu/&#34; target=&#34;_blank&#34;&gt;링크&lt;/a&gt;의 내용을 확인하자.&lt;/p&gt;

&lt;p&gt;설치과정이 완료되고 다시 우분투 터미널에 다음의 코드를 입력하면 Rstudio-server가 실행되며 윈도우의 브라우저 에서 접속할 수 있는 상태가 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo rstudio-server start
$ sudo rstudio-server stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sudo rstudio-server start&lt;/code&gt;는 Rstudio-server를 실행시키는 명령어 이고 &lt;code&gt;sudo rstudio-server stop&lt;/code&gt;은 Rstudio-server를 종료시키는 명령어이다. 작업이나 분석이 끝나면 꼭 &lt;code&gt;sudo rstudio-server stop&lt;/code&gt;를 입력하여 R 서버를 종료시키자.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo rstudio-server stop&lt;/code&gt; 코드를 입력하여 서버를 실행시켰다면 윈도우 브라우저 주소창에 &lt;code&gt;localhost:8787&lt;/code&gt;을 입력하자. 파이어폭스, 크롬, 익스플로러, 엣지&amp;hellip; 어느 브라우저를 이용해도 상관없다. 다만 개인이 운용하는 서버나 AWS등의 클라우드 서버를 운용할 경우 &lt;code&gt;localhost:8787&lt;/code&gt;의 localhost 대신 서버 ip주소를 입력해야 한다.&lt;/p&gt;

&lt;p&gt;브라우저에 다음과 같은 화면이 뜨면 정상적으로 작동한 것이다. 화면의 &lt;strong&gt;Username&lt;/strong&gt;과 &lt;strong&gt;Password&lt;/strong&gt;는 WSL의 개인 사용자명과 비밀번호이다. 이제 기본적인 설치과정은 완료되었다.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src = &#34;https://user-images.githubusercontent.com/30010992/66693087-0f000600-ece0-11e9-92ac-815dac274d55.PNG&#34; width=80%&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-의존성-문제-해결-및-기본-설정&#34;&gt;3. 의존성 문제 해결 및 기본 설정&lt;/h3&gt;

&lt;h4 id=&#34;1-java-rjava-설치&#34;&gt;1) JAVA, rJava 설치&lt;/h4&gt;

&lt;p&gt;R에서 사용하는 다양한 패키지 중에서 JAVA에 의존하는 패키지가 있다. 예를들어 한글 형태소 분석을 위한 R패키지인 &lt;strong&gt;KoNLP&lt;/strong&gt;는 JAVA와 rJava가 설정되어 있지 않으면 사용할 수 없다.
우분투에서 JAVA를 설치하는 방법은 다양하다. 기본저장소에서 제공하는 Open-JDK를 설치할 수도 있고 오라클에서 제공하는 JDK를 직접 다운받아 설치할 수도 있다. 여기서는 개인적으로 가장 간단하다고 생각하는 방법을 안내한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install default-jdk
$ sudo update-alternatives --config java
$ sudo R CMD javareconf
$ sudo apt install r-cran-rjava
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;첫번째 코드를 우분투 터미널에 입력하여 JDK를 설치한다. 컴퓨터에 여러가지 버전의 JAVA가 설치되어 있다면 두번째 코드를 실행시켜 실제 이용할 JAVA를 선택한다. 한가지 종류만 설치되어 있을 경우 이 과정은 생략한다.
마지막 코드인  &lt;code&gt;sudo R CMD javareconf&lt;/code&gt;는 자바 환경변수를 설정하는 것이다. 윈도우 상에서도 JAVA를 설치할 경우  시스템 변수에 &lt;strong&gt;JAVA_HOME&lt;/strong&gt;과 &lt;strong&gt;PATH&lt;/strong&gt;를 추가하는 과정을 거치는 것과 유사한 과정이다. 우분투에서도 편집기 창을 열어 직접 환경을 설정할 수도 있지만 그냥 간단하게 &lt;code&gt;sudo R CMD javareconf&lt;/code&gt;입력으로 마무리 하자.&lt;/p&gt;

&lt;p&gt;네번째 코드인 &lt;code&gt;sudo apt install r-cran-rjava&lt;/code&gt;는 cran을 통해 우분투 시스템 상에 &lt;strong&gt;rJava&lt;/strong&gt;를 설치하는 것이다. 인터넷에는 이 과정을 생략하고 바로 R 스크립트 창에서 &lt;code&gt;install.packages(&amp;quot;rJava&amp;quot;)&lt;/code&gt;를 실행하면 된다고 하지만 내 경우에  &lt;code&gt;sudo apt install r-cran-rjava&lt;/code&gt;를 생략하면 다음 과정에 오류가 났다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;install.packages(&amp;quot;rJava&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자바를 설정하는 마지막 과정으로 R스크립트 상에서 &lt;strong&gt;rJava&lt;/strong&gt;를 설치하기 위해  &lt;code&gt;install.packages(&amp;quot;rJava&amp;quot;)&lt;/code&gt;를 실행한다.&lt;/p&gt;

&lt;h4 id=&#34;2-wsl-한글-언어-로케일-설정&#34;&gt;2) WSL 한글 언어 로케일 설정&lt;/h4&gt;

&lt;p&gt;다음으로 WSL의 한글 언어팩 설치 및 로케일에 대한 설정을 해야 한다. 이 과정이 없으면  &lt;code&gt;c(&amp;quot;UTF-8&amp;quot;, &amp;quot;CP949&amp;quot;, &amp;quot;EUC-KR&amp;quot;)&lt;/code&gt;관련 기본 인코딩 문제가 발생하며 &lt;strong&gt;KoNLP&lt;/strong&gt; 설치가 불가능하다.&lt;/p&gt;

&lt;p&gt;다음의 코드를 우분투 터미널에 실행시켜 언어팩을 설치하고 로케일 설정을 변경한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install language-pack-ko
sudo locale-gen ko_KR.UTF-8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;한글 언어팩 설치가 완료되면 우분투 터미널에  &lt;code&gt;sudo nano /etc/profile&lt;/code&gt;의 코드를 실행시켜 편집창의 마지막 행에 &lt;code&gt;export LANG=ko_KR.UTF-8&lt;/code&gt; 을 추가한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo nano /etc/profile
export LANG=ko_KR.UTF-8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음으로 우분투 터미널에 &lt;code&gt;sudo nano /etc/default/locale&lt;/code&gt;을 실행시켜 편집창의 마지막 행에  &lt;code&gt;LANG=&amp;quot;en_US.UTF-8&amp;quot;&lt;/code&gt;과 &lt;code&gt;LANG=&amp;quot;ko_KR.UTF-8&amp;quot;&lt;/code&gt;의 두 줄을 추가한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo nano /etc/default/locale
LANG=&amp;quot;en_US.UTF-8&amp;quot;
LANG=&amp;quot;ko_KR.UTF-8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;마지막으로 한글 글꼴을 설치한다. 글꼴이 없으면 나중에 그래프를 그릴때 한글 글꼴이 깨지는 경우가 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install fonts-unfonts-core fonts-unfonts-extra fonts-baekmuk fonts-nanum fonts-nanum-coding fonts-nanum-extra
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-의존성-문제-해결을-위한-기타-라이브러리-및-r패키지-설치&#34;&gt;3) 의존성 문제 해결을 위한 기타 라이브러리 및 R패키지 설치&lt;/h4&gt;

&lt;p&gt;사용하다 보면 &lt;code&gt;The previous R session was abnormally terminated due to an unexpected crash&lt;/code&gt;의 문구와 함께 R이 갑자기 중단되는 경우가 생긴다. 그 때마다 검색해 보면 SSL오류라거나 의존성 있는 R패키지가 제대로 설치되지 않았다거나 하는 등 문제도 다양하고 해결책도 다양하다. 그냥 다음의 코드를 우분투 터미널에 실행시켜 한꺼번에 해결하자.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install libcurl4-openssl-dev libssl-dev libxslt1-dev libxml2-dev libcurl4-gnutls-dev
sudo apt-get install r-cran-rcpp r-cran-inline r-cran-rcpp r-cran-rsqlite r-cran-devtools r-cran-tidyverse 
sudo apt-get install gfortran curl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;마지막 다음의 코드는 R스크립트에서 실행시킨다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;install.packages(&amp;quot;curl&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-blogdown-운영시-블로그-페이지가-깨지는-문제&#34;&gt;4) blogdown 운영시 블로그 페이지가 깨지는 문제&lt;/h4&gt;

&lt;p&gt;윈도우에서 &lt;strong&gt;blogdown&lt;/strong&gt;을 실행시켰을 때는 겪지 못한 문제인데 우분투 R에서 블로그의 새로운 글을 작성하고 &amp;lsquo;blogdown:::serve_site()&amp;lsquo;로 사이트를 생성하면 블로그 페이지가 전부 깨지는 문제가 발생했다.
검색하니 블로그 페이지의 주소가 제대로 생성되지 않기 때문이라고 한다. 설정파일인 &lt;strong&gt;config.toml&lt;/strong&gt;에  &lt;code&gt;relativeurls = true&lt;/code&gt;의 옵션을 추가한다.&lt;/p&gt;

&lt;h3 id=&#34;4-해결하지-못한-문제&#34;&gt;4. 해결하지 못한 문제&lt;/h3&gt;

&lt;p&gt;마찬가지로 &lt;strong&gt;blogdown&lt;/strong&gt;에서 블로그를 빌드할 때 생기는 문제이다. 이 블로그의 경우, 블로그 대문에 배경화면이 되는 이미지 파일을 &lt;strong&gt;static&lt;/strong&gt; 폴더에 두었는데, 우분투 상에서 &amp;lsquo;blogdown:::serve_site()&amp;lsquo;를 실행하면 배경화면이 나타나지 않는다. &lt;strong&gt;static&lt;/strong&gt; 폴더에 접근이 안되서 생기는 문제라고는 하는데 아직까지 해결책은 찾지 못했다. 이 문제는 차차 해결할 예정이다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>데이터 프레임에서 짝수행과 홀수행 선별하는 다른 방법</title>
      <link>/post/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%84%EB%A0%88%EC%9E%84%EC%97%90%EC%84%9C-%EC%A7%9D%EC%88%98%ED%96%89%EA%B3%BC-%ED%99%80%EC%88%98%ED%96%89-%EC%84%A0%EB%B3%84%ED%95%98%EB%8A%94-%EB%8B%A4%EB%A5%B8-%EB%B0%A9%EB%B2%95/</link>
      <pubDate>Fri, 04 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/post/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%84%EB%A0%88%EC%9E%84%EC%97%90%EC%84%9C-%EC%A7%9D%EC%88%98%ED%96%89%EA%B3%BC-%ED%99%80%EC%88%98%ED%96%89-%EC%84%A0%EB%B3%84%ED%95%98%EB%8A%94-%EB%8B%A4%EB%A5%B8-%EB%B0%A9%EB%B2%95/</guid>
      <description>


&lt;p&gt;데이터 프레임에서 짝수행과 홀수행을 구분하는 더 간단한 방법이 있어서 메모할 겸 올려본다.&lt;/p&gt;
&lt;p&gt;TRUE, FALSE 논리연산을 이용한 방법이 가장 간단해 보인다. 응용하면 짝수열과 홀수열도 간단히 선택할 수 있다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## 데이터셋 구성
a &amp;lt;- rnorm(99)
b &amp;lt;- runif(99)
c &amp;lt;- rnorm(99)
d &amp;lt;- runif(99)
e &amp;lt;- rnorm(99)
f &amp;lt;- runif(99)
g &amp;lt;- rnorm(99)
h &amp;lt;- runif(99)
i &amp;lt;- rnorm(99)
j &amp;lt;- runif(99)
dt &amp;lt;-data.frame(a,b,c,d,e,f,g,h,i,j)

## 필요한 행 선택하기
dt[c(TRUE, FALSE), ]  # (1, 3, 5, 7... 행 선택)
dt[c(FALSE, TRUE), ]  # (2, 4, 6, 7... 행 선택)
dt[c(TRUE, FALSE, FALSE), ]  # (1, 4, 7, 10...행 선택)
dt[c(TRUE, FALSE, FALSE, FALSE, FALSE), ]

## 필요한 열 선택하기
dt[ ,c(TRUE, FALSE)]  # (1, 3, 5, 7... 열 선택)
dt[ ,c(FALSE, TRUE)]  # (2, 4, 6, 7... 열 선택)
dt[ ,c(TRUE, FALSE, FALSE)] # (1, 4, 7, 10...열 선택)
dt[ ,c(TRUE, FALSE, FALSE, FALSE, FALSE)]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;seq()&lt;/strong&gt;함수를 이용하지 않고 &lt;strong&gt;열 번호(row_number)&lt;/strong&gt;를 2로 나눈 나머지를 이용하여 선별할 수도 있다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df &amp;lt;- data.frame(V1 = seq(26), V2 = letters)

df %&amp;gt;% filter(row_number() %% 2 == 0) ## 짝수열 
df %&amp;gt;% filter(row_number() %% 2 == 1) ## 홀수열
df %&amp;gt;% filter(row_number() %% 3 == 1)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>데이터셋의 짝수행과 홀수행 구분</title>
      <link>/post/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%84%EB%A0%88%EC%9E%84%EC%97%90%EC%84%9C-%EC%A7%9D%EC%88%98%ED%96%89%EA%B3%BC-%ED%99%80%EC%88%98%ED%96%89-%EC%84%A0%EB%B3%84%ED%95%98%EA%B8%B0/</link>
      <pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/post/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%84%EB%A0%88%EC%9E%84%EC%97%90%EC%84%9C-%EC%A7%9D%EC%88%98%ED%96%89%EA%B3%BC-%ED%99%80%EC%88%98%ED%96%89-%EC%84%A0%EB%B3%84%ED%95%98%EA%B8%B0/</guid>
      <description>


&lt;p&gt;&lt;a href=&#34;https://youtu.be/w7Q_eKN5r-I?t=136&#34;&gt;유투브&lt;/a&gt;에서 말하길, &lt;strong&gt;파이썬&lt;/strong&gt;을 이용하면 모듈과 자료를 불러들이는 과정을 포함하여 단 세 줄의 코드로 데이터셋에서 짝수행을 뽑을수 있다고 한다. &lt;strong&gt;R&lt;/strong&gt;에서도 할 수 있겠다 싶어 머리를 굴려봤다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)
data &amp;lt;- read.csv(&amp;quot;filename&amp;quot;)
data_even &amp;lt;- filter(data, seq_len(nrow(data))%% 2==0) # 짝수행
data_odd &amp;lt;- filter(data, seq_len(nrow(data))%% 2==1) # 홀수행&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 코드를 단계별로 설명하면,&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;strong&gt;seq_len()&lt;/strong&gt; 함수를 이용하여 데이터 테이블의 마지막 행 까지 인덱스를 부여&lt;/li&gt;
&lt;li&gt;각각의 인덱스를 2로 나눈 나머지가 0인 행과 1인 행을 각각 필터링&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위 두 단계를 거쳐 짝수행과 홀수행을 구분하였다. 파이썬 만큼 깔끔하지는 않지만 어쨌든 패키지를 불러와서 짝수행을 뽑는 것 까지 3~4줄의 &lt;strong&gt;R&lt;/strong&gt;코드면 된다.&lt;/p&gt;
&lt;p&gt;이 방법을 이용해서 &lt;a href=&#34;http://www.ypec.re.kr/modedg/contentsView.do?ucont_id=CTX000007&amp;amp;srch_menu_nix=t7W3a9w7&#34;&gt;&lt;strong&gt;청소년정책분석평가센터&lt;/strong&gt;&lt;/a&gt;가 매년 공개하는 청소년정책성과(청소년의 삶의질, 청소년참여활동수준) 점수를 하나의 테이블로 간단히 정리하였다. 연도별 17개 시도의 성과정보를 스크래핑 하는 코드는 &lt;a href=&#34;https://github.com/gbkim01/web_scraping_with_R/blob/master/2_%EC%97%B0%EB%8F%84%EB%B3%84%EC%B2%AD%EC%86%8C%EB%85%84%EC%A0%95%EC%B1%85%EC%84%B1%EA%B3%BC.R&#34;&gt;&lt;strong&gt;Github&lt;/strong&gt;&lt;/a&gt;에 올렸다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>URL 리스트 취합</title>
      <link>/post/web-scraping-with-r-www-climatewatchdata-org/</link>
      <pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate>
      <guid>/post/web-scraping-with-r-www-climatewatchdata-org/</guid>
      <description>


&lt;p&gt;웹 스크래핑은 타겟이 되는 인터넷 페이지의 url을 확인하는 것으로 시작한다. 한두 개의 웹페이지라면 모르겠지만 스크래핑 대상물이 여러 페이지에 흩어져 있다면 인터넷 주소를 취합하는 간단한 작업도 초보자에겐 큰 장애물이 된다. 그러나 문법이 조금 익숙한 사용자라면 반복문을 사용하여 좀 더 간편하게 필요한 url 리스트를 구성할 수 있다. 통상의 웹페이지 주소는 main URl에 인덱스가 붙는 형식으로 구성되어 있기 때문이다. 예컨데 이렇게 말이다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;main &amp;lt;- &amp;quot;www.main_url.co.kr/search=&amp;quot;
search &amp;lt;- c(&amp;quot;apple&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;pineapple&amp;quot;)
index &amp;lt;- &amp;quot;&amp;amp;indexpage=&amp;quot;

url_list &amp;lt;- NULL

for (i in 1:3){
  for (j in 1:3) {
    url &amp;lt;- paste0(main, search[i], index, j)
    url_list &amp;lt;- append(url_list, url)
  }
}

url_list&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;www.main_url.co.kr/search=apple&amp;amp;indexpage=1&amp;quot;    
## [2] &amp;quot;www.main_url.co.kr/search=apple&amp;amp;indexpage=2&amp;quot;    
## [3] &amp;quot;www.main_url.co.kr/search=apple&amp;amp;indexpage=3&amp;quot;    
## [4] &amp;quot;www.main_url.co.kr/search=orange&amp;amp;indexpage=1&amp;quot;   
## [5] &amp;quot;www.main_url.co.kr/search=orange&amp;amp;indexpage=2&amp;quot;   
## [6] &amp;quot;www.main_url.co.kr/search=orange&amp;amp;indexpage=3&amp;quot;   
## [7] &amp;quot;www.main_url.co.kr/search=pineapple&amp;amp;indexpage=1&amp;quot;
## [8] &amp;quot;www.main_url.co.kr/search=pineapple&amp;amp;indexpage=2&amp;quot;
## [9] &amp;quot;www.main_url.co.kr/search=pineapple&amp;amp;indexpage=3&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;climate-watch-data--&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;climate watch data의 페이지 구성&lt;/h3&gt;
&lt;center&gt;
&lt;img src = &#34;https://user-images.githubusercontent.com/30010992/66132557-36940600-e630-11e9-9982-e39c42dc0967.jpg&#34; width=80%&gt;
&lt;/center&gt;
&lt;p&gt;그러나 이번에 스크래핑한 &lt;a href=&#34;https://www.climatewatchdata.org/ndcs/country/IND/sectoral-information&#34;&gt;www.climatewatchdata.org&lt;/a&gt;는 웹페이지가 매우 독특한 구성으로 되어있어 위의 경우처럼 간단한 반복문으로는 url을 취합하기 어려웠다. 그림처럼 개별 섹션(Sectoral Mitication Targets) 및 섹터(Energy | Renewable Energy) 별로 해당되는 목록을 취합하기 위해서는 섹터 및 섹션별 url을 따로 만들어야 했는데 다음과 같은 복잡한 과정을 거쳐야 했기 때문이다.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;먼저 url &lt;em&gt;&lt;a href=&#34;https://www.climatewatchdata.org/ndcs/country/IND/sectoral-information&#34; class=&#34;uri&#34;&gt;https://www.climatewatchdata.org/ndcs/country/IND/sectoral-information&lt;/a&gt;&lt;/em&gt;로 들어가 총 5개의 섹션 리스트를 가져온다.&lt;/li&gt;
&lt;li&gt;각각의 섹션리스트를 모두 소문자로 변경하여 각 섹션별 주소를 구성한다. (ex: &lt;em&gt;&lt;a href=&#34;https://www.climatewatchdata.org/ndcs/country/IND/sectoral-information?section=sectoral_mitigation_targets&#34; class=&#34;uri&#34;&gt;https://www.climatewatchdata.org/ndcs/country/IND/sectoral-information?section=sectoral_mitigation_targets&lt;/a&gt;&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;각 섹션별로 모든 섹터 리스트(ex, Energy | Renewable Energy, Energy | Renewable Energy:Biofuels….)를 가져온다.&lt;/li&gt;
&lt;li&gt;모든 섹터 리스트를 기호 &lt;strong&gt;“|”&lt;/strong&gt; 를 기준으로 쪼갠 다음 &lt;strong&gt;“|”&lt;/strong&gt; 뒤에 위치하고 있는 문자를 소문자로 변경한다.&lt;/li&gt;
&lt;li&gt;위 4에서 만든 섹션을 가지고 각 섹션별 전체 주소리스트를 구성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위의 5단계를 거쳐 최종적으로 만들어진 &lt;em&gt;&lt;a href=&#34;https://www.climatewatchdata.org/ndcs/country/IND/sectoral-information?section=sectoral_mitigation_targets&amp;amp;sector=renewable_energy&#34; class=&#34;uri&#34;&gt;https://www.climatewatchdata.org/ndcs/country/IND/sectoral-information?section=sectoral_mitigation_targets&amp;amp;sector=renewable_energy&lt;/a&gt;&lt;/em&gt;의 주소는 &lt;strong&gt;sectoral_mitication&lt;/strong&gt; 섹션의 &lt;strong&gt;renewable_energy&lt;/strong&gt;섹터의 목록을 스크래핑하는 기본 url이 된다.&lt;/p&gt;
&lt;p&gt;이상의 5가지 단계를 실행하기 위해 다음의 코드를 작성하였다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;########### Section 취합 #############
### 1. 대문 page 이동
remDr$navigate(&amp;quot;https://www.climatewatchdata.org/ndcs/country/IND/sectoral-information?section=none&amp;amp;sector=none&amp;quot;) 
## 대문 page source 읽기
html_page &amp;lt;- remDr$getPageSource()[[1]]

### 2. section 주소  : section_link 주소
section &amp;lt;- read_html(html_page) %&amp;gt;% html_nodes(&amp;quot;div.accordion-styles__title__2PD3i&amp;quot;) %&amp;gt;% html_text() 
section_adr &amp;lt;- str_replace_all(str_to_lower(section), &amp;quot; &amp;quot;, &amp;quot;_&amp;quot;) ##대문자 to 소문자, 공백을 &amp;quot;_&amp;quot;로 대체


########### 주소 취합 #############
main &amp;lt;- &amp;quot;https://www.climatewatchdata.org/ndcs/country/IND/sectoral-information?section=&amp;quot;
section_sector &amp;lt;- NULL
link_list &amp;lt;- NULL

for (i in 1:length(section_adr)) {
  
  section_link &amp;lt;- paste0(main, section_adr[i], &amp;quot;&amp;amp;sector=none&amp;quot;)
  
  ### 3. sector 주소  : sector_link 주소
  remDr$navigate(section_link)
  Sys.sleep(3) # 3초 딜레이
  
  section_page &amp;lt;- remDr$getPageSource()[[1]]
  sector &amp;lt;- read_html(section_page) %&amp;gt;% html_nodes(&amp;quot;div.ndcs-country-accordion-styles__subAccordion__1zDx7&amp;quot;) %&amp;gt;% html_nodes(&amp;quot;div.accordion-styles__title__2PD3i&amp;quot;) %&amp;gt;% html_text() 
  
  link_list &amp;lt;- cbind(i, section[i], section_adr[i], sector)
  section_sector &amp;lt;- rbind(section_sector, link_list)
}

section_sector &amp;lt;- data.frame(section_sector)
names(section_sector) &amp;lt;- c(&amp;quot;index&amp;quot;, &amp;quot;section&amp;quot;, &amp;quot;section_adr&amp;quot;, &amp;quot;sector&amp;quot;)
section_sector$sector_adr &amp;lt;- str_to_lower(section_sector$sector)
section_sector$sector_adr &amp;lt;- str_split_fixed(section_sector$sector_adr, &amp;quot;[|]&amp;quot;, 2)[,2]
section_sector$sector_adr &amp;lt;- str_trim(section_sector$sector_adr)
section_sector$sector_adr &amp;lt;- str_replace_all(section_sector$sector_adr, &amp;quot;[-:/ ]&amp;quot;, &amp;quot;_&amp;quot;)
section_sector$sector_adr &amp;lt;- str_replace_all(section_sector$sector_adr, &amp;quot;__&amp;quot;, &amp;quot;_&amp;quot;)

### 주소 만들기
link_pool &amp;lt;- NULL
for (i in 1:dim(section_sector)[1]) {
  link &amp;lt;- paste0(main, section_sector$section_adr[i], &amp;quot;&amp;amp;sector=&amp;quot;, section_sector$sector_adr[i])
  link_pool &amp;lt;- append(link_pool, link)
}

section_sector &amp;lt;- cbind(section_sector, link_pool)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 해당 웹페이지가 java로 구성되었는지 &lt;strong&gt;rvest&lt;/strong&gt;로는 html 태그를 확인할 수 없었다. 차선책으로 &lt;strong&gt;Rselenium&lt;/strong&gt;을 사용하였으며 끊김없는 안정적인 스크래핑을 위해 중간중간 &lt;em&gt;Sys.sleep(3)&lt;/em&gt;의 코드를 추가하였다.&lt;/p&gt;
&lt;p&gt;이 외에 데이터를 취합하는 내용을 포함한 전체 코드는 &lt;a href=&#34;https://github.com/gbkim01/web_scraping_with_R/blob/master/1_climate_watch_data_org.R&#34;&gt;Github&lt;/a&gt;에 올려두었다.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
